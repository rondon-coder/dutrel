// Prisma schema (Dutrel - Autopay + Credit + Fintech Foundation + Bill Account Monitoring)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum HouseholdRole {
  MEMBER
  PAYER
  SECONDARY_PAYER
}

enum MemberStatus {
  ACTIVE
  INVITED
  LEFT
  REMOVED
}

enum HouseholdKind {
  ROOMMATES
  PROPERTY
}

enum BucketType {
  GROUP
  INDIVIDUAL
}

enum BucketResponsibilityRole {
  PRIMARY
  SECONDARY
}

enum BucketVariability {
  FIXED
  VARIABLE
}

enum BucketCadence {
  MONTHLY
  QUARTERLY
  OTHER
}

enum ObligationStatus {
  OPEN
  CLOSED
  DISPUTED
  REVERSED
}

enum ReceiptStatus {
  MEMBER_SUBMITTED
  PENDING_PAYER_REVIEW
  VERIFIED
  DISPUTED
  AUTO_CLOSED_TIMEOUT
  ESCALATED
}

enum ObligationCategory {
  RENT
  UTILITY
  OTHER
}

/**
 * Fintech partner abstraction (foundation only)
 * - UNIT / DWOLLA can be added later
 * - Keep generic so we can swap providers
 */
enum PaymentPartner {
  NONE
  PLAID
  UNIT
  DWOLLA
  STRIPE_TREASURY
  OTHER
}

/**
 * Where this bucket expects funds to live.
 * INTERNAL = user manually funds / uses their own bank + autopay
 * VIRTUAL_ACCOUNT = provider-issued account/routing dedicated to this bucket
 */
enum FundingMode {
  INTERNAL
  VIRTUAL_ACCOUNT
}

/**
 * Lifecycle for a provider-issued virtual account.
 */
enum VirtualAccountStatus {
  PENDING
  ACTIVE
  SUSPENDED
  CLOSED
}

/**
 * Tokenized/linked external funding source (foundation only)
 * This is NOT a “card”. It can represent ACH funding tokens later.
 */
enum FundingSourceStatus {
  PENDING
  VERIFIED
  DISABLED
}

/**
 * Bank connection status (Plaid read-only in Phase 2A)
 */
enum BankConnectionStatus {
  ACTIVE
  DISCONNECTED
  ERROR
}

/**
 * Unified attachment system.
 * Attachments live on buckets and can be pinned into the household feed.
 */
enum AttachmentKind {
  FILE
  LINK
  NOTE
}

enum AttachmentType {
  LEASE
  HOA
  VENDOR
  INVOICE
  RECEIPT
  OTHER
}

/**
 * Storage provider for non-custodial file objects
 * - R2 (Cloudflare) or S3 (AWS)
 * - We store stable objectKey in DB; presigned URLs generated by API only
 */
enum StorageProvider {
  R2
  S3
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // AUTOPAY SETTINGS (non-custodial; user enables autopay externally)
  autopayEnabled          Boolean   @default(false)
  autopayExternalNickname String?
  autopayLastConfirmedAt  DateTime?

  // CREDIT REPORTING OPT-IN (individual only)
  creditReportingEnabled Boolean   @default(false)
  creditReportingSince   DateTime?

  memberships HouseholdMember[]
  receipts    Receipt[]         @relation("ReceiptUploader")

  // Fintech foundations (future ACH/custody partner phases)
  fundingSources FundingSource[]

  // Bank monitoring (Plaid read-only in Phase 2A)
  bankConnections BankConnection[]

  // Attachments created by user
  bucketAttachments BucketAttachment[] @relation("BucketAttachmentCreator")

  @@index([autopayEnabled])
  @@index([creditReportingEnabled])
}

model Household {
  id        String        @id @default(cuid())
  name      String
  kind      HouseholdKind @default(ROOMMATES)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  members HouseholdMember[]
  buckets  Bucket[]
}

model HouseholdMember {
  id             String        @id @default(cuid())
  householdId    String
  userId         String
  role           HouseholdRole @default(MEMBER)
  successionRank Int           @default(0)
  status         MemberStatus  @default(ACTIVE)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  household     Household      @relation(fields: [householdId], references: [id], onDelete: Cascade)
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  bucketMembers BucketMember[]
  responsibleFor BucketResponsibility[]

  @@unique([householdId, userId])
  @@index([householdId])
  @@index([userId])
  @@index([status])
}

model Bucket {
  id          String            @id @default(cuid())
  householdId String
  type        BucketType
  name        String
  cadence     BucketCadence     @default(MONTHLY)
  variability BucketVariability @default(VARIABLE)

  ownerUserId String?

  autopayEnabledAt       DateTime?
  notificationPauseUntil DateTime?
  bufferTargetCents      Int       @default(0)

  /**
   * FOUNDATION: Funding mode selector (default INTERNAL)
   * If VIRTUAL_ACCOUNT, we attach VirtualAccount record(s).
   */
  fundingMode FundingMode @default(INTERNAL)

  // CREDIT REPORTING (individual only)
  creditReportingEnabled     Boolean  @default(false)
  creditReportingStatus      String   @default("INACTIVE")
  creditReportingProvider    String   @default("NONE")
  creditReportingActivatedAt DateTime?
  creditReportingPausedAt    DateTime?
  creditReportingReason      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  household   Household      @relation(fields: [householdId], references: [id], onDelete: Cascade)
  obligations Obligation[]
  members     BucketMember[]
  responsibleMembers BucketResponsibility[]

  // Fintech foundations (future partner phases)
  virtualAccounts VirtualAccount[]

  // Attachments
  attachments BucketAttachment[]

  @@index([householdId])
  @@index([ownerUserId])
  @@index([fundingMode])
  @@index([creditReportingEnabled])
}

model BucketMember {
  id                String   @id @default(cuid())
  bucketId          String
  householdMemberId String
  createdAt         DateTime @default(now())

  bucket          Bucket          @relation(fields: [bucketId], references: [id], onDelete: Cascade)
  householdMember HouseholdMember @relation(fields: [householdMemberId], references: [id], onDelete: Cascade)

  @@unique([bucketId, householdMemberId])
  @@index([bucketId])
  @@index([householdMemberId])
}

model BucketResponsibility {
  id                String                   @id @default(cuid())
  bucketId          String
  householdMemberId String
  role              BucketResponsibilityRole @default(PRIMARY)
  createdAt         DateTime                 @default(now())

  bucket          Bucket          @relation(fields: [bucketId], references: [id], onDelete: Cascade)
  householdMember HouseholdMember @relation(fields: [householdMemberId], references: [id], onDelete: Cascade)

  @@unique([bucketId, householdMemberId])
  @@index([bucketId])
  @@index([householdMemberId])
  @@index([role])
}

model Obligation {
  id       String             @id @default(cuid())
  bucketId String
  status   ObligationStatus   @default(OPEN)
  category ObligationCategory @default(OTHER)

  periodStart DateTime?
  periodEnd   DateTime?
  dueDate     DateTime?
  amountCents Int       @default(0)

  closedAt         DateTime?
  closedByUserId   String?
  reopenedAt       DateTime?
  reopenedByUserId String?
  reopenReason     String?

  isRecoveryMode Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bucket   Bucket    @relation(fields: [bucketId], references: [id], onDelete: Cascade)
  receipts Receipt[]

  // Plaid monitoring assist (optional)
  paymentMatches PaymentMatch[]

  @@index([bucketId])
  @@index([status])
  @@index([dueDate])
  @@index([category])
  @@index([closedByUserId])
}

model Receipt {
  id               String        @id @default(cuid())
  obligationId     String
  status           ReceiptStatus @default(PENDING_PAYER_REVIEW)
  uploadedByUserId String
  reviewedByUserId String?
  reviewedAt       DateTime?
  disputeReason    String?
  fileUrl          String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  obligation Obligation @relation(fields: [obligationId], references: [id], onDelete: Cascade)
  uploadedBy User       @relation("ReceiptUploader", fields: [uploadedByUserId], references: [id], onDelete: Cascade)

  @@index([obligationId])
  @@index([status])
  @@index([uploadedByUserId])
  @@index([reviewedByUserId])
}

model BucketAttachment {
  id              String @id @default(cuid())
  bucketId        String
  createdByUserId String

  kind AttachmentKind
  type AttachmentType @default(OTHER)

  title             String
  pinnedToHousehold Boolean @default(false)

  // FILE (durable object storage)
  storageProvider StorageProvider?
  objectKey       String?
  originalName    String?
  mimeType        String?
  sizeBytes       Int?
  sha256Hex       String?

  // (legacy / interim)
  fileUrl String?

  // LINK
  url String?

  // NOTE
  noteText String? @db.Text

  metadataJson String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bucket    Bucket @relation(fields: [bucketId], references: [id], onDelete: Cascade)
  createdBy User   @relation("BucketAttachmentCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)

  @@index([bucketId])
  @@index([pinnedToHousehold])
  @@index([createdAt])
  @@index([createdByUserId])
  @@index([storageProvider])
}

model BankConnection {
  id     String @id @default(cuid())
  userId String

  partner PaymentPartner       @default(PLAID)
  status  BankConnectionStatus @default(ACTIVE)

  // Plaid identifiers (read-only)
  plaidItemId     String? @unique
  accessTokenEnc  String? @db.Text
  institutionName String?
  institutionId   String?

  // user-facing
  label     String?
  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  accounts BankAccount[]

  @@index([userId])
  @@index([status])
  @@index([partner])
}

model BankAccount {
  id           String @id @default(cuid())
  connectionId String

  plaidAccountId String? @unique
  name           String?
  officialName   String?
  maskLast4      String?
  type           String?
  subtype        String?

  // bill account semantics
  isBillAccount Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  connection       BankConnection     @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  balanceSnapshots BalanceSnapshot[]
  paymentMatches   PaymentMatch[]

  @@index([connectionId])
  @@index([isBillAccount])
}

model BalanceSnapshot {
  id            String   @id @default(cuid())
  bankAccountId String

  availableCents Int?
  currentCents   Int?
  asOf           DateTime

  createdAt DateTime @default(now())

  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  @@index([bankAccountId])
  @@index([asOf])
}

model PaymentMatch {
  id            String @id @default(cuid())
  obligationId  String
  bankAccountId String

  partner      PaymentPartner @default(PLAID)
  partnerTxnId String?        @unique

  amountCents Int
  postedAt    DateTime?
  description String?

  status       String  @default("MATCHED")
  metadataJson String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  obligation  Obligation  @relation(fields: [obligationId], references: [id], onDelete: Cascade)
  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  @@index([obligationId])
  @@index([bankAccountId])
  @@index([partner])
}

model FundingSource {
  id     String @id @default(cuid())
  userId String

  partner PaymentPartner      @default(NONE)
  status  FundingSourceStatus @default(PENDING)

  label       String?
  bankName    String?
  last4       String?
  accountType String?

  providerToken String?
  providerRefId String?
  metadataJson  String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([partner, providerRefId])
  @@index([userId])
  @@index([partner])
  @@index([status])
}

model VirtualAccount {
  id       String @id @default(cuid())
  bucketId String

  partner PaymentPartner       @default(NONE)
  status  VirtualAccountStatus @default(PENDING)

  nickname     String?
  bankName     String?
  routingLast4 String?
  accountLast4 String?

  providerAccountId  String?
  providerCustomerId String?
  metadataJson       String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bucket Bucket @relation(fields: [bucketId], references: [id], onDelete: Cascade)

  @@unique([partner, providerAccountId])
  @@index([bucketId])
  @@index([partner])
  @@index([status])
}

model ActionLog {
  id          String   @id @default(cuid())
  householdId String
  actorUserId String
  action      String
  entityType  String
  entityId    String

  metadataJson String?  @db.Text
  createdAt    DateTime @default(now())

  @@index([householdId])
  @@index([actorUserId])
  @@index([createdAt])
}